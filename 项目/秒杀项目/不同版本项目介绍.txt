miaosha_1      无优化，单纯的mysql锁实现
miaosha_2     增加redis
miaosha_3     增加本地缓存，增加zookeeper解决本地缓存的问题
miaosha_4     增加mq，添加分布式session（使用spring-session）


总结：该项目一开始只使用了mysql的行锁以保证库存的准确性来实现秒杀功能，吞吐量不高。
后面通过一步步优化，如添加redis，实现先访问redis库存量，拦截了大部分请求。
产生问题：问题就是数据不一致，当redis的库存减了，但是后面处理校验出现问题时，mysql库存不减。
处理：trycatch，在catch中重新添加上redis的库存。

进一步优化，使用本地缓存，创建一个售完的标志。当库存售完，便标志为true。
产生的问题：如果在分布式架构下，那么当其中一个节点redis减完，然后标志为true，但是业务处理失败，redis又加回去，而标志位也改false。但是其他节点都为true了。这时库存是还有的，不过只有一个节点能接收请求，其他节点被标志位拒绝了。如果该节点宕机了，那么就会出现售完但是还有库存的现象。
处理：解决分布式下数据一致性问题。使用了zookeeper。

优化，使用mq来处理service层。
产生问题：一致性问题，订单服务执行完了，但是库存服务却执行错误。导致数据不一致。
	不过由于rabbitmq能够保证数据不丢失（三方面），所以修改库存服务代码，使得能够执行成功就行。
	而且必须保证业务是准确的，然后再发送给库存，库存服务只需要正确消费就行。
	比如，下订单必须先知道库存，然后又库存才能下订单，下完订单再发消息给库存服务消费，然后再返回成功。库存服务只需要直接减库存就行，因为在下订单前就知道库存够所以不应该会失败。否则，如果没有先判断库存是否充足，那么下订单，发消息，返回前端成功，库存服务消费消息，却发现库存不足，那么就会导致不一致。


